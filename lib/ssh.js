'use strict';
const forge = require('node-forge');
const ssh2 = require('ssh2');


const generateKey = (comment = 'autogenerated') => new Promise(function (resolve, reject) {
    forge.rsa.generateKeyPair({bits: 2048, workers: -1}, function (err, keypair) {
        if (err) return reject(err);
        return resolve({
            publicKey: forge.ssh.publicKeyToOpenSSH(keypair.publicKey, comment),
            privateKey: forge.ssh.privateKeyToOpenSSH(keypair.privateKey),
        });
    });
});

const connection = (options) => new Promise(function (resolve, reject) {
    const conn = new ssh2.Client();
    conn.on('ready', function () {
        return resolve(conn);
    });
    conn.on('error', err => {
        return reject(err);
    });
    conn.connect(Object.assign({}, {port: 22}, options));
});

const getConnection = async (options = {}) => {
    const retryLimit = options.retryLimit || 12;
    const retryDelay = options.retryDelay || 5 * 1000;

    for (let i = 0; i <= retryLimit || 10; i++) {
        try {
            return await connection(options);
        } catch (err) {
            console.log(`Delay ${retryDelay / 1000} seconds to retry SSH connection.`);
            await new Promise(r => setTimeout(r, retryDelay));
        }
    }
    throw new Error('Unable to get SSH connection');
};

const execute = (command, connection) => new Promise(async (resolve, reject) => {
    const conn = await getConnection(connection);
    let buffer = '';
    conn.exec(command, function (err, stream) {
        if (err) return reject(err);
        stream.on('close', function (code, signal) {
            conn.end();
            if (code) {
                return reject(code, signal);
            }
            return resolve(buffer);
        }).on('data', function (data) {
            buffer += data;
        }).stderr.on('data', function (data) {
            buffer += data;
        });
    });
});

module.exports = {
    generateKey,
    execute,
};
