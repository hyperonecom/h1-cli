'use strict';
const forge = require('node-forge');
const ssh2 = require('ssh2');


const generateKey = (comment = 'autogenerated') => new Promise((resolve, reject) =>
    forge.rsa.generateKeyPair({
        bits: 2048,
        workers: -1,
    }, (err, keypair) => {
        if (err) return reject(err);
        return resolve({
            publicKey: forge.ssh.publicKeyToOpenSSH(keypair.publicKey, comment),
            privateKey: forge.ssh.privateKeyToOpenSSH(keypair.privateKey),
        });
    })
);

const connection = (options) => new Promise((resolve, reject) => {
    const conn = new ssh2.Client();
    conn.on('ready', () => resolve(conn));
    conn.on('error', err => reject({
        msg: 'Unable to connect to SSH server',
        ssh_err: err,
    }));
    conn.connect(Object.assign({}, {port: 22}, options));
});

const getConnection = async (options = {}) => {
    const retryLimit = options.retryLimit || 12;
    const retryDelay = options.retryDelay || 5 * 1000;

    for (let i = 0; i <= retryLimit; i++) {
        try {
            return await connection(options);
        } catch (err) {
            await new Promise(r => setTimeout(r, retryDelay));
        }
    }
    throw new Error('Unable to get SSH connection');
};

const execute = (command, connection) => new Promise((resolve, reject) =>
    getConnection(connection).then(conn => {
        let buffer = '';
        conn.exec(command, (err, stream) => {
            if (err) return reject({
                msg: 'Unable to execute SSH command',
                command: command,
                ssh_err: err,
            });
            stream
                .on('close', (code, signal) => {
                    conn.end();
                    if (code) {
                        return reject({
                            msg: 'Execution of SSH command fail',
                            command: command,
                            code: code,
                            signal: signal,
                        });
                    }
                    return resolve(buffer);
                })
                .on('data', data => buffer += data)
                .stderr.on('data', data => buffer += data);
        });
    })
);

module.exports = {
    generateKey,
    execute,
};
