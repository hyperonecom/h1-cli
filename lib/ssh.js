'use strict';
const forge = require('node-forge');
const ssh2 = require('ssh2');


const generateKey = (comment = 'autogenerated') => new Promise((resolve, reject) =>
    forge.rsa.generateKeyPair({
        bits: 2048,
        workers: -1,
    }, (err, keypair) => {
        if (err) return reject(err);
        return resolve({
            publicKey: forge.ssh.publicKeyToOpenSSH(keypair.publicKey, comment),
            privateKey: forge.ssh.privateKeyToOpenSSH(keypair.privateKey),
        });
    })
);

const connection = (options) => new Promise((resolve, reject) => {
    const conn = new ssh2.Client();
    conn.on('ready', () => resolve(conn));
    conn.on('error', err => reject({
        msg: 'Unable to connect to SSH server',
        ssh_err: err,
    }));
    conn.connect(Object.assign({}, {port: 22}, options));
});

const getConnection = async (options = {}) => {
    const retryLimit = options.retryLimit || 12;
    const retryDelay = options.retryDelay || 5 * 1000;
    let last_err;
    for (let i = 0; i <= retryLimit; i++) {
        try {
            return await connection(options);
        } catch (err) {
            await new Promise(r => setTimeout(r, retryDelay));
            last_err = err;
        }
    }
    throw last_err;
};

const execute = (command, connection) => new Promise((resolve, reject) =>
    getConnection(connection).then(conn => {
        const buffer = [];
        console.log(`[${connection.host}]:${command}`);
        conn.exec(command, (err, stream) => {
            if (err) return reject({
                msg: 'Unable to execute SSH command',
                command: command,
                ssh_err: err,
            });
            stream
                .on('close', (code, signal) => {
                    conn.end();
                    const output = Buffer.concat(buffer).toString('utf-8');
                    if (code) {
                        return reject({
                            msg: 'Execution of SSH command fail',
                            command: command,
                            code: code,
                            output,
                            signal: signal,
                        });
                    }
                    return resolve(output);
                })
                .on('data', data => buffer.push(data))
                .stderr.on('data', data => buffer.push(data));
        });
    }).catch(reject)
);

const getSftpStream = (connection) => new Promise((resolve, reject) =>
    getConnection(connection).then(conn => {
        conn.sftp((err, stream) => {
            if (err) return reject({
                msg: 'Unable to start SFTP session',
                ssh_err: err,
            });
            return resolve({stream, conn});
        });
    }).catch(reject)
);

const putFile = (path, content, connection) => new Promise((resolve, reject) =>
    getSftpStream(connection).then(({conn, stream}) => {
        const wstream = stream.createWriteStream(path);
        wstream.on('error', err => reject(err));
        wstream.end(content, 'utf-8', () => {
            conn.end();
            return resolve();
        });
    }).catch(reject)
);

const rmFile = (path, connection) => new Promise((resolve, reject) =>
    getSftpStream(connection).then(({conn, stream}) => {
        stream.unlink(path, err => {
            conn.end();
            if (err) return reject(err);
            return resolve();
        });
    }).catch(reject)
);
const lsFile = (path, connection) => new Promise((resolve, reject) =>
    getSftpStream(connection).then(({conn, stream}) => {
        stream.readdir(path, (err, list) => {
            conn.end();
            if (err) return reject(err);
            return resolve(list);
        });
    }).catch(reject)
);

const mkDir = (path, connection) => new Promise((resolve, reject) =>
    getSftpStream(connection).then(({conn, stream}) => {
        stream.mkdir(path, (err) => {
            conn.end();
            if (err) return reject(err);
            return resolve();
        });
    }).catch(reject)
);


const execResource = (resource, auth, cmd) => {
    console.log(new Date().toISOString(), `[resource: ${resource.id}]`, cmd);
    return execute(cmd, Object.assign({
        host: resource.fqdn,
        username: resource.id,
    }, auth));
};

const execVm = (resource, auth, cmd) => execResource(resource, Object.assign({username: 'guru'}, auth), cmd);

module.exports = {
    generateKey,
    execute,
    putFile,
    rmFile,
    mkDir,
    execResource,
    execVm,
    lsFile,
};
